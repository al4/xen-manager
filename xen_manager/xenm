#!/usr/bin/python
# -*- coding: utf-8 -*-


import os, sys, inspect, time, argparse, getpass, ConfigParser, csv
import XenAPI               # Gee I wonder why we need this
from subprocess import call # for external system calls
import socket               # for socket.getfqdn()

# Our modules
from xenm_class import block_device
from xenm_class import disk_image
from xenm_class import host
from xenm_class import xen_vm     # This is the same as virtual_machine but takes an ID as input and not a name.
                            # This is the more "correct" way of doing things and functions should be
                            # updated to use this class instead

import pprint # for debugging
pp = pprint.PrettyPrinter(indent=2) # for debugging

# XenAPI doc: http://docs.vmd.citrix.com/XenServer/6.0.0/1.0/en_gb/api/

### Housekeeping functions. TODO - implement proper logging
def error(message):
    # Throw message and exit
    print("ERROR: " + str(message))
    # disconnect()
    exit()

def notify(message):
    # Notify user but don't quit
    print("NOTICE: " + str(message))

### Functions for the sub-commands
def action_list():
    # Polls all Xen servers to gather data
    global args

    hosts=args.hosts
    username=args.username
    password=args.password
    puppet_path=args.puppet_path

    # Lists which we append to (start with headings in first row)
    header=[['name_label', 'pool', 'power_state', 'restart_priority', 'start_delay', 'order'],
            ['----------', '----', '-----------', '----------------', '-----------', '-----']]
    data_vms=[]

    for host_name in hosts:
        # Initialise the host
        myhost = host(host_name, username, password)
        session = myhost.connect()

        try:
            # Get the name of the pool on this host
            pool_name = myhost.get_pool()

            if verbose:
                print("Getting VMs from " + myhost.name + "...")

            vms = myhost.get_vms()

            # Build a list of VMs that are not templates or control domains
            for vm_id in vms:
                myvm = xen_vm(myhost, vm_id)
                record = myvm.get_record()

                if not(record["is_a_template"]) and not(record["is_control_domain"]):
                    data_vms.append([
                        record["name_label"],
                        pool_name,record["power_state"],
                        record["ha_restart_priority"],
                        record["start_delay"],
                        record["order"]
                        ])
        finally:
            myhost.disconnect()

    if verbose: print("")
    col_width = max(len(word) for row in data_vms for word in row) + 2

    for row in header:
        print("".join(word.ljust(col_width) for word in row))
    for row in data_vms:
        print("".join(word.ljust(col_width) for word in row))

    return data_vms

def action_pools():
    # Lists all pools

    global args

    hosts=args.hosts
    username=args.username
    password=args.password

    header=[['name_label', 'host'],['----------','----']]
    data_pools=[]

    for host_name in hosts:
        # Create new host object and connect
        myhost = host(host_name, username, password)
        myhost.connect()

        try:
            pool_name = myhost.get_pool()
            data_pools.append([pool_name,host_name])

        finally:
            myhost.disconnect()

    if verbose: print("") # Add line between verbose messages and output - looks neater

    col_width = max(len(word) for row in data_pools for word in row) + 2

    for row in header:
        print("".join(word.ljust(col_width) for word in row))
    for row in data_pools:
        print("".join(word.ljust(col_width) for word in row))

    return data_pools

def action_start():
    # TODO: check that all args are set
    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname

    # Get host name
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    # Get vm_id
    vm_id = myhost.get_vm(vmname)

    # Create xen_vm object
    myvm = xen_vm(myhost, vm_id)
    myvm.read_from_xen()

    try:
        result = power_on(myvm)
    finally:
        myhost.disconnect()

    return result

def power_on(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Starting " + vm.name + "...")
        result = vm.start()
        if result == 0:
            print("Start succeeded")
            return result
        elif result == 1:
            notify("VM already running")
            return result
        else:
            error("Unknown return value from vm.start()")
    else:
        notify("Check failed")
        return check_result

def action_stop():

    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    force = args.force

    vmname = args.vmname
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    # Get vm_id
    vm_id = myhost.get_vm(vmname)

    # Create xen_vm object
    myvm = xen_vm(myhost, vm_id)

    try:
        myvm.read_from_xen()
        if args.force:
            notify('performing hard shutdown')
            result = hard_shutdown(myvm)
        else:
            result = shutdown(myvm)
    finally:
        myhost.disconnect()

    return result

def shutdown(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Stopping " + vm.name + "...")
        result = vm.clean_shutdown()
        if result == 0:
            print("Stop succeeded")
            return result
        elif result == 1:
            notify("VM already halted")
            return result
        else:
            error("Unknown return value from vm.clean_shutdown()")
    else:
        notify("Check failed")
        return check_result

def hard_shutdown(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Crashing " + vm.name + "...")
        result = vm.hard_shutdown()
        if result == 0:
            print("Stop succeeded")
            return result
        elif result == 1:
            notify("VM already halted")
            return result
        else:
            error("Unknown return value from vm.clean_shutdown()")
    else:
        notify("Check failed")
        return check_result


def action_restart():
    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    force=args.force

    vmname = args.vmname
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    # Get vm_id
    vm_id = myhost.get_vm(vmname)

    # Create xen_vm object
    myvm = xen_vm(myhost, vm_id)
    myvm.read_from_xen()

    try:
        if myvm.power_state == "Running":
            if force:
                notify('Performing hard reboot')
                result = hard_reboot(myvm)
            else:
                result = clean_reboot(myvm)
        elif myvm.power_state == "Halted":
            notify(myvm.name + " was halted")
            result = power_on(myvm)
    finally:
        myhost.disconnect()

    return result

def clean_reboot(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Restarting " + vm.name + "...")
        result = vm.clean_reboot()
        if result == 0:
            print("Reboot succeeded")
        elif result == 1:
            notify("reboot failed")
        else:
            error("Unknown return value from vm.clean_reboot()")
        return result
    else:
        notify("Check failed")
        return check_result


def hard_reboot(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Restarting " + vm.name + "...")
        result = vm.hard_reboot()
        if result == 0:
            print("Reboot succeeded")
        elif result == 1:
            notify("reboot failed")
        else:
            error("Unknown return value from vm.clean_reboot()")
        return result
    else:
        notify("Check failed")
        return check_result


def action_remove():

    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    puppet_path = args.puppet_path

    # Get the host this vm resides on
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    # Get vm_id
    vm_id = myhost.get_vm(vmname)

    # Create xen_vm object
    myvm = xen_vm(myhost, vm_id)
    myvm.read_from_xen()

    try:
        shutdown(myvm)
        remove_disks(myvm)
        destroy(myvm)
        puppet_clean(myvm)
    finally:
        myhost.disconnect()

def destroy(vm):

    check_result = vm.read_from_xen()

    if check_result == 0:
        print("Removing " + vm.name + " from " + vm.host.name + "...")

        result = vm.destroy()
        if result == 0:
            print("Remove succeeded")
            return 0
        else:
            return result

def remove_disks(vm):
    # Remove all disks from a VM.
    vbd_ids = vm.read_vbds()

    if len(vbd_ids) == 0:
        notify(vm.name + "has no disks to remove")

    # vms can have multiple vbds so we loop over them
    for id in vbd_ids:
        # This next bit is probably quite hard to read.
        # The vbd and vdi classes both need and ID and session passed to them.
        # for the vbd, this is the ID return from the vm class (as it is one of its block devices)
        # for vdi, this is the ID returned from the vbd class (vbd.VDI)
        vbd = block_device(id, vm.session)

        # vbd can only have one vdi (at least I hope so, it is not returning a list), so here
        # we check if it is NULL and if not delete it
        if vbd.vdi_id == 'OpaqueRef:NULL':
            # No vdi to delete
            continue
        elif len(vbd.vdi_id) == 46:
            # Looks like a valid VDI attached to a valid VBD attached to a VM we are removing...
            vdi = disk_image(vbd.vdi_id, vm.session)

            # Check this VDI is not attached to any other VBDs
            if len(vdi.VBDs) > 1:
                notify("Not removing VBD with ID " + vdi.id + " as it is attached to another VM")
            else:
                print("Deleting " + vbd.device + " from " + vm.name + "...")
                vdi.destroy()
        else:
            error = "Unexpected VDI ID"
            return 1
    return 0

def action_spawn():
    # Function to spawn a new VM from template
    # Would be nice if this also set the name_label on associated VDIs.

    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    puppet_path = args.puppet_path
    template = args.template
    vmlist = args.vmlist

    # for spawn, we can only work with a single host
    host_name = hosts[0]

    # instantiate host
    myhost = host(host_name, username, password)
    myhost.connect()
    myhost.get_pool()

    if len(hosts) > 1:
        #error("Spawn requires that only one host is set, define a single host on the command line with the --host option")
        # We take the first one instead:
        notify("Host was not set explicitly, using " + myhost.pool + " (" + myhost.name + ") to spawn VM")

    try:
        # get id of template
        template_id = myhost.get_vm(template)

        # Check template exists
        if template_id == None:
            error("Template " + template + " does not exist on pool " + myhost.pool)

        # object for the template (to get the ID and make sure it is valid)
        mytemplate = xen_vm(myhost, template_id)
        # get the template attributes from xen into the object
        mytemplate.read_from_xen()

        # Check vmname doesn't already exist
        check = myhost.get_vm(vmname)
        if check != None:
            error(vmname + " already exists")

        newvm = clone_from_template(mytemplate, vmname)
        newvm.read_from_xen()

        set_ha_properties(newvm,vmlist)
        power_on(newvm)
    finally:
        myhost.disconnect()

def clone_from_template(mytemplate, vm_name):
    ''' Inputs: mytemplate  ==  template xen_vm object (must have a host)
                vm_name     ==  string, name of vm
        Returns: xen_vm object (created from the clone)
    '''

    # Check that we don't already have a valid vm with the same name
    check = mytemplate.host.get_vm(vm_name)
    if check != None:
        error(vm_name + " already exists")

    # Make sure template VM is actually a template
    is_template = mytemplate.get_template_status()
    if is_template == False:
        error("Template VM given is not a template")
    elif is_template == True:
        print("Cloning " + mytemplate.name + " to " + vm_name + "...")
        new_id = mytemplate.clone(mytemplate.id, vm_name)

        # Instantiate a new VM object with the VM we just created by cloning. Pass through host object of the template
        myvm = xen_vm(mytemplate.host,new_id)

        check = myvm.read_from_xen()
        if check != 0:
            error("Clone failed")

        # Cloned VMs are made as templates, we need to set is_a_template to false
        if myvm.is_a_template == True:
            myvm.set_template_status(False)
        elif myvm.is_a_template == False:
            notify("Expected new clone to be a template but this was not the case, investigate?")
        else:
            error("Could not get template status of " + myvm.name)

    else: error("Could not get template status of " + mytemplate.name)

    # return the new vm object
    return myvm

def action_respawn():
    # Function to respawn an existing VM from template

    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    puppet_path = args.puppet_path
    template = args.template
    vmlist = args.vmlist

    # for spawn, we can only work with a single host
    host_name = hosts[0]

    # instantiate host
    myhost = host(host_name, username, password)
    myhost.connect()
    myhost.get_pool()

    if len(hosts) > 1:
        #error("Spawn requires that only one host is set, define a single host on the command line with the --host option")
        # We take the first one instead:
        notify("Host was not set explicitly, using " + myhost.pool + " (" + myhost.name + ") to spawn VM")

    try:
        # get id of template
        template_id = myhost.get_vm(template)
        vm_id = myhost.get_vm(vmname)

        # Check template exists
        if template_id == None:
            error("Template " + template + " does not exist on pool " + myhost.pool)

        # Check vm exists
        check = myhost.get_vm(vmname)
        if check == None:
            error(vmname + " does not exist")

        # object for the template (to get the ID and make sure it is valid)
        mytemplate = xen_vm(myhost, template_id)
        # get the template attributes from xen into the object
        mytemplate.read_from_xen()

        # object for the existing vm
        myvm = xen_vm(myhost, vm_id)
        myvm.read_from_xen()

        # ready to go, destroy
        result = shutdown(myvm)
        if result != 0: notify("Failed to shut down " + myvm.name)

        result = remove_disks(myvm)
        if result != 0: error("Failed to remove disks from " + myvm.name)

        result = destroy(myvm)
        if result != 0: error("Failed to remove vm " + myvm.name)

        result = puppet_clean(myvm)

        # clone a new one
        newvm = clone_from_template(mytemplate, vmname)
        newvm.read_from_xen()

        # Set HA and power on
        set_ha_properties(newvm,vmlist)
        power_on(newvm)

    finally:
        myhost.disconnect()

    # try:
    #   mytemplate.read_id()
    #   mytemplate.read_from_xen

    #   shutdown(vm)
    #   destroy(vm)
    #   puppet_clean(vm)
    #   clone_from_template(mytemplate, vm)
    #   set_ha_properties(vm)
    #   power_on(vm)
    # finally:
    #   vm.disconnect_host
    #   mytemplate.disconnect_host

def action_enforce():
    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    puppet_path = args.puppet_path
    template = args.template
    vmlist = args.vmlist

    # Get name from args, it is required from the CLI for this function
    vmname = args.vmname
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    try:
        # Get vm_id
        vm_id = myhost.get_vm(vmname)

        # Create xen_vm object
        myvm = xen_vm(myhost, vm_id)
        myvm.read_from_xen()

        # Check
        check_result = myvm.read_from_xen()

        if check_result == 0:
            # Do it
            set_ha_properties(myvm)
        else:
            error("Check failed")
    finally:
        myhost.disconnect()

def set_ha_properties(myvm, vmlist):
    # Sets the HA properties of a VM. Inputs: vm object, vmlist (string containing path to CSV file containing VMs and HA priorites)

    # Check the vm list is present
    if not os.path.isfile(vmlist):
        message = 'VM List "' + str(vmlist) + '" does not exist'
        error(message)

    count = 0

    # Read csv file
    with open(vmlist, 'rb') as csvfile:
        reader = csv.reader(csvfile, delimiter=' ')

        # Get current values
        current_order = myvm.get_order()
        current_start_delay = myvm.start_delay
        current_priority = myvm.ha_restart_priority

        # Find out what the HA values should be
        # Check the config file:
        count = 0
        for row in reader:
            # See if this is the row we want
            if row[1] == myvm.name:
                count += 1

                # TODO: currently only the order is defined in the config file
                order = row[0]
                start_delay = 0         # This is not in the config file yet, may want to make it configurable later.
                priority = "restart"    # Also not in the config file yet. But if the VM is in there we assume it is important, so always restart
            else:
                continue

    # if we didn't find the vm in the config, use defaults:
    if count == 0:
        print("Could not find entry for " + myvm.name + " in " + vmlist + ", using defaults")
        order = default_order
        start_delay = default_start_delay
        priority = default_ha_restart_priority

    # Now set them if they differ
    if int(current_order) != int(order):
        print(myvm.name + " order: " + str(current_order) + " => " + str(order))
        myvm.set_order(str(order))
    if int(current_start_delay) != int(start_delay):
        print(myvm.name + " start_delay: " + str(current_start_delay) + " => " + str(start_delay))
        myvm.set_start_delay(str(start_delay))
    if str(current_priority) != str(priority):
        print(myvm.name + " priority: " + str(current_priority) + " => " + str(priority))
        myvm.set_ha_restart_priority(str(priority))

def action_enforce_all():
    # Loop over each VM on each host, look for appropriate entry in the CSV file, and fix if different

    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmlist = args.vmlist

    # Check the vm list is present
    if not os.path.isfile(vmlist):
        message = 'VM List "' + str(vmlist) + '" does not exist'
        error(message)

    # Load CSV data into list
    with open (vmlist, 'rb') as csvfile:
        reader = csv.reader(csvfile, delimiter=' ')

        ha_config = {}
        # Loop over each entry
        for row in reader:
            #pp.pprint(row)
            vmname = row[1]
            order = int(row[0])         # We set as string but this should be an int for comparisons (and eliminates leading 0's)
            priority = 'restart'        # Hard-coded for now as we're not defining or computing anywhere
                                        ## Overridden by hack later
            start_delay = 0             # Also hard-coded for now until we compute it somewhere

            # Put the values in a dictionary. The key is prefixed by vmname
            ha_config[vmname + '_order'] = order
            ha_config[vmname + '_priority'] = priority
            ha_config[vmname + '_start_delay'] = start_delay

    count = 0   # count for changes made

    # ha_config is loaded, now to compare and set it
    for host_name in hosts:
        # Initialise the host
        myhost = host(host_name, username, password)
        session = myhost.connect()

        try:
            # Get the name of the pool on this host
            pool_name = myhost.get_pool()
            if verbose: print("Checking VMs on " + pool_name + "...")
            vm_list = myhost.get_vms()

            # Loop over VMs
            for vm_id in vm_list:
                myvm = xen_vm(myhost, vm_id)
                myvm.read_from_xen()    # Loads the values we need into the class

                # Don't want to modify templates or control domains!
                if myvm.is_control_domain == False and myvm.is_a_template == False:
                    # Check the values
                    current_order = myvm.order
                    current_start_delay = myvm.start_delay
                    current_priority = myvm.ha_restart_priority

                    if myvm.name + "_order" in ha_config:
                        # this VM has config defined, set it
                        order = ha_config[myvm.name + '_order']
                        start_delay = ha_config[myvm.name + '_start_delay']
                        priority = ha_config[myvm.name + '_priority']

                        # Hack to set start_delay to "restart if possible" if order > 1000
                        # because we aren't defining this in config yet
                        if int(order) > 1000:
                            priority = 'best-effort'
                        else:
                            priority = 'restart'
                    else:
                        # print(myvm.name + " is not in config")
                        # enforce defaults
                        order = default_order
                        start_delay = default_start_delay
                        priority = default_ha_restart_priority

                    # Now set them
                    if int(order) != int(current_order):
                        count += 1
                        print(myvm.name + " order: " + str(current_order) + " => " + str(order))
                        myvm.set_order(str(order))
                    if int(current_start_delay) != int(start_delay):
                        count += 1
                        print(myvm.name + " start_delay: " + str(current_start_delay) + " => " + str(start_delay))
                        myvm.set_start_delay(str(start_delay))
                    if str(current_priority) != str(priority):
                        count += 1
                        print(myvm.name + " priority: " + str(current_priority) + " => " + str(priority))
                        myvm.set_ha_restart_priority(str(priority))
                else:
                    continue
        finally:
            myhost.disconnect()
    print("Changed " + str(count))

def action_status():
    global args

    # Store config options in variables
    hosts = args.hosts
    username = args.username
    password = args.password
    vmname = args.vmname
    vmlist = args.vmlist

    vmname = args.vmname
    host_name = get_host(vmname)

    if host_name == None:
        error(vmname + " does not exist on any defined hosts")

    header=[['name_label', 'pool', 'power_state', 'restart_priority', 'start_delay', 'order'],
            ['----------', '----', '-----------', '----------------', '-----------', '-----']]
    data_vms=[]

    # Create new host object and connect
    myhost = host(host_name, username, password)
    myhost.connect()

    try:
        # Get vm_id
        vm_id = myhost.get_vm(vmname)

        # Create xen_vm object
        myvm = xen_vm(myhost, vm_id)
        myvm.read_from_xen()

        pool_name = myvm.host.get_pool()
        record = myvm.get_record()

        data_vms.append([
            record["name_label"],
            pool_name,
            record["power_state"],
            record["ha_restart_priority"],
            record["start_delay"],
            record["order"]
                ])

        if verbose: print("")

        col_width1 = max(len(word) for row in data_vms for word in row) + 2
        col_width2 = max(len(word) for row in header for word in row) + 2

        col_width = max(col_width1,col_width2)

        for row in header:
            print("".join(word.ljust(col_width) for word in row))
        for row in data_vms:
            print("".join(word.ljust(col_width) for word in row))


    finally:
        myhost.disconnect()

    return 0

## Helper functions

def get_host(vm_name):
    # Find the host a VM is on.
    # Input: vm name
    # Returns: host name

    if not str(vm_name): error("must pass vm_name to get_host")
    host_list = []

    for host_name in args.hosts:
        # Get a connection
        myhost = host(host_name, args.username, args.password)
        myhost.connect()

        if verbose: print("Looking for " + vm_name + " on " + host_name)
        try:
            # Get vm id
            vm_id = myhost.get_vm(vm_name)

            # kinda bad as
            if vm_id == None:
                # vm not found
                pass
            elif len(vm_id) == 46:
                # found it
                host_list.append(host_name)
        finally:
            myhost.disconnect()

    if len(host_list) == 0:
        print("Could not find " + vm_name + " on any hosts")
        return None
    if len(host_list) > 1:
        print("Found " + vm_name + " on multiple hosts")
        return 1
    if len(host_list) == 1:
        if verbose: print("Found " + vm_name + " on " + host_list[0])
        return host_list[0]
    return 0

def puppet_clean(vm):
    # Get fully qualified domain from vm name
    fqdn = socket.getfqdn(vm.name)

    # Check puppet is on this box
    if not os.path.isfile(args.puppet_path):
        notify(args.puppet_path + " does not exist on this machine. Please run 'puppet cert clean " + fqdn + "' on nms")
        # We could do an ssh call here....
        return 1

    if verbose: print("Cleaning up " + fqdn + " from puppet...")
    return_code = call([puppet_path,"cert","clean",fqdn], shell=False)

    if str(return_code) == "24":
        # Puppet returns 24 when it can't find the hostname. Usually this is because it is not a fqdn,
        # socket.getfqdn returns exactly what you give it if it can't find a fully-qualified host name.
        notify("Could not find the hostname in puppet, ensure DNS entries are set correctly")
    return return_code

## end of functions

# Parse the commandline arguments using Python's argparse.
parser = argparse.ArgumentParser(description='Manages our Xen cluster. First positional argument is action, use {action} -h for more help.')

parser.add_argument("--configfile", "-c", help="config file to use (/etc/opta/xenm/xenm.cfg by default)")
parser.add_argument("--username", "-u", help="user name for Xen Server (default set in config")
parser.add_argument("--password", "-p", help="root password for Xen Server (default set in config)") # Username is not configurable on the CLI at present as our license only allows root access.
parser.add_argument('--hosts', help='Xen host(s) to connect to. These hosts must be the master of their cluster. Separate multiple hosts with commas.')
parser.add_argument('--vmlist', help='CSV file with a list of VMs and priorities')
parser.add_argument('--verbose', '-v', action='store_true', default=False, help='print more output')

# Default options. It is reasonable to guess configfile, but host should be explicit in config or as argument
parser.set_defaults(configfile='/etc/opta/xenm/xenm.cfg')

# We setup subparsers for each mode
subparsers = parser.add_subparsers(dest='action')

# Parent parser for modes which operate on a single VM
parent_parser_onevm = argparse.ArgumentParser(add_help=False)
parent_parser_onevm.add_argument('vmname', help='name of VM to perform action on')
parent_parser_onevm.add_argument('--force', '-f', action='store_true', default=False, help='force the specified action (currently only works for stop and restart; changes the API methods to hard_shutdown and hard_reboot respectively)')
# parent_parser_onevm.set_defaults(vmname=None)

# Parent for any option that uses a template
parent_parser_template = argparse.ArgumentParser(add_help=False)
parent_parser_template.add_argument('--template', '-t', help='name of template to use')
# parent_parser_template.set_defaults(template=None)

# The subparsers, most of which include one of the parents above
parser_list = subparsers.add_parser('list', help='list all VMs')
parser_listpools = subparsers.add_parser('list-pools', help='list all pools')
parser_pools = subparsers.add_parser('pools', help='alias for list-pools')   # Alias of list-pools
parser_start = subparsers.add_parser('start', help='starts a VM', parents=[parent_parser_onevm])
parser_stop = subparsers.add_parser('stop', help='performs a shutdown, clean unless force is set', parents=[parent_parser_onevm])
parser_status = subparsers.add_parser('status', help='shows the status of a VM', parents=[parent_parser_onevm])
parser_restart = subparsers.add_parser('restart', help='performs a reboot, clean unless force is set', parents=[parent_parser_onevm])
parser_remove = subparsers.add_parser('remove', help='removes a VM', parents=[parent_parser_onevm])
parser_spawn = subparsers.add_parser('spawn', help='spawns a new VM', parents=[parent_parser_onevm, parent_parser_template])
parser_respawn = subparsers.add_parser('respawn', help='removes and spawns a new copy of a VM', parents=[parent_parser_onevm, parent_parser_template])
parser_enforce = subparsers.add_parser('enforce', help='enforce the HA policy on one VM', parents=[parent_parser_onevm])
parser_enforce_all = subparsers.add_parser('enforce-all', help='check the HA policy on all VMs and enforce the policy (config must be set)')

# Set the functions to be called by each sub-parser
parser_list.set_defaults(func=action_list)
parser_listpools.set_defaults(func=action_pools)
parser_pools.set_defaults(func=action_pools)
parser_start.set_defaults(func=action_start)
parser_stop.set_defaults(func=action_stop)
parser_status.set_defaults(func=action_status)
parser_restart.set_defaults(func=action_restart)
parser_remove.set_defaults(func=action_remove)
parser_spawn.set_defaults(func=action_spawn)
parser_respawn.set_defaults(func=action_respawn)
parser_enforce.set_defaults(func=action_enforce)
parser_enforce_all.set_defaults(func=action_enforce_all)

# We parse here to get the configfile, but it is overwritten later
args = parser.parse_args()

# Get config options from xenm.cfg if not set on command line
configfile = args.configfile
config = ConfigParser.RawConfigParser()

# Check our config file exists
if os.path.isfile(configfile):
    config.read(configfile)
else:
    message = 'Config file "' + str(configfile) + '" does not exist'
    error(message)



# Set parser defaults from configfile before we parse
parser.set_defaults(
    username=config.get('Main', 'username'),
    password=config.get('Main', 'password'),
    hosts=config.get('Main', 'hosts').split(','),
    vmlist=config.get('Input', 'vmlist'),
    puppet_path=config.get('Main', 'puppet_path'),       # not exposed on CLI as wouldn't really be used...
    implants_file=config.get('Input', 'implants_file')  # Not currently used
    )
parent_parser_template.set_defaults(
    template=config.get('Input', 'template')
    )

## Old code. Better to set the defaults using config file as above and parse with defaults set
# Override config if set on command line
# if args.hosts != None: # args.hosts is a list and and hasattr requires a string for some reason! So the default must be set above
#     hosts = args.hosts.split(',')
# if hasattr(args, "password") and args.password != None:
#     password = args.password
# TEMP HACK:
# These break for functions where the arg parser doesn't have the attribute, so they are commented out for now.
# As a consequence template and vmlist can not be overridden on the command line

# if hasattr(args, "template") and args.template != None:
#     template = args.template
# if hasattr(args, "vmlist") and args.template != None:
#     vmlist = args.vmlist

# Parse the arguments
args = parser.parse_args()

# Store config options in variables
# hosts = args.hosts
# username = config.get('Main', 'username')       # not in args anywhere so get straight from config
# password = args.password
# puppet_path = config.get('Main', 'puppet_path')# not in args anywhere so get straight from config
# template = args.template
# vmlist = args.vmlist
# implants_file = config.get('Input', 'implants_file') # Not currently used

# Set verbose mode. args.verbose is set by action='store_true' option in parser.
if args.verbose:
    verbose=True
    print("Verbose on")
    pp.pprint(vars(args))
else:
    verbose=False

if verbose: print('Hosts: ' + str(args.hosts))

# Get defaults (not sure if we'll use these):
default_ha_restart_priority = config.get('HA Defaults', 'restart_priority')
default_order = config.get('HA Defaults', 'order')
default_start_delay = config.get('HA Defaults', 'start_delay')

# Call the function selected by set_default(func=)
result = args.func()

# # Analyse what is returned
# if result == 1:
#   error("function returned error code")

exit()





